0:
	0:1
	1:277
	2:554
	3:831
	4:1106
	5:1381
	6:1656
	7:1931
	8:2206
	9:2481
	10:2756
1:
	0:2
	1:30
	2:59
	3:88
	4:115
	5:142
	6:169
	7:196
	8:223
	9:250
2:
	0:3
	1:6
	2:10
	3:14
	4:18
	5:20
	6:22
	7:24
	8:26
	9:28
3:
	1:4
4:
	10:5
5:                The approach is as follows:
6:
	1:7
	10:9
7:
	10:8
8:                    }
9:                        break;
10:
	1:11
	10:13
11:
	10:12
12:                AddChar(starter.chars.Get(i));
13:                        opTree = this.dt2;
14:
	1:15
	10:17
15:
	10:16
16:
17:            if (longAddress < 0)
18:
	10:19
19:            return this.PaveTo(Hasher(0, address)).Add(element);
20:
	10:21
21:                return false;
22:
	10:23
23:                    referenceHolder.Add(++referenceHolder.counter, member);
24:
	10:25
25:            {
26:
	10:27
27:            sr = new StreamReader(path);
28:
	10:29
29:                    }
30:
	0:31
	1:34
	2:38
	3:42
	4:46
	5:48
	6:50
	7:52
	8:54
	9:56
	10:58
31:
	1:32
32:
	10:33
33:                        for (int i = 3; i < nextLine.Length; i++)
34:
	1:35
	10:37
35:
	10:36
36:                    else if (nextLine[1] == '9')
37:                    {
38:
	1:39
	10:41
39:
	10:40
40:
41:                    {
42:
	1:43
	10:45
43:
	10:44
44:        public DecTree<E> Tree { get; set; }
45:            }
46:
	10:47
47:            try
48:
	10:49
49:                if (FocusTree.dtC == null)
50:
	10:51
51:        /// </summary>
52:
	10:53
53:                    fs.Write(nextline_bytes, 0, nextline.Length);
54:
	10:55
55:                the index is already set from the else case.
56:
	10:57
57:                    else if (nextLine[1] == '8')
58:        public DecTree<E> dt2;
59:
	0:60
	1:63
	2:67
	3:71
	4:75
	5:77
	6:79
	7:81
	8:83
	9:85
	10:87
60:
	1:61
61:
	10:62
62:                        {
63:
	1:64
	10:66
64:
	10:65
65:                else
66:                        break;
67:
	1:68
	10:70
68:
	10:69
69:
70:
71:
	1:72
	10:74
72:
	10:73
73:        public abstract ConvertibleObject FromString(string convertedValue);
74:
75:
	10:76
76:        public E Get(long address)
77:
	10:78
78:                FocusTree.dtC = null;
79:
	10:80
80:                catch (NullReferenceException)
81:
	10:82
82:                    fs.Write(nextline_bytes, 0, nextline.Length);
83:
	10:84
84:                        {
85:
	10:86
86:                    {
87:        public DecTree<E> dtP;
88:
	0:89
	1:92
	2:96
	3:100
	4:102
	5:104
	6:106
	7:108
	8:110
	9:112
	10:114
89:
	1:90
90:
	10:91
91:                            for (int i = 4; i < nextLine.Length; i++)
92:
	1:93
	10:95
93:
	10:94
94:                }
95:                case 7:
96:
	1:97
	10:99
97:
	10:98
98:        /// STARTS AT ZERO, increments by +1.
99:                        break;
100:
	10:101
101:                while (address > 0)
102:
	10:103
103:        public E GetL(long address)
104:
	10:105
105:        public bool RmL(long address)
106:
	10:107
107:        /// $"\t{Child Index}: {Index of child tree}\n")
108:
	10:109
109:                order[7] = currTree.dt7;
110:
	10:111
111:                            for (int i = 3; i < nextLine.Length; i++)
112:
	10:113
113:                //parse for index, find it, store in index variable.
114:        static int TWO = 2;
115:
	0:116
	1:119
	2:123
	3:127
	4:129
	5:131
	6:133
	7:135
	8:137
	9:139
	10:141
116:
	1:117
117:
	10:118
118:                            {
119:
	1:120
	10:122
120:
	10:121
121:    /// Mutable DecTree Variant of String
122:                        break;
123:
	1:124
	10:126
124:
	10:125
125:                r_tree.Add(1, new DecString("\0"));
126:                        opTree = this.dt9;
127:
	10:128
128:                return default(DecTree<E>);
129:
	10:130
130:        public E GetL(string address)
131:
	10:132
132:        }
133:
	10:134
134:            foreach (DecTree<E> member in order)
135:
	10:136
136:                        byte[] nextline_bytes = new byte[nextline.Length];
137:
	10:138
138:                            {
139:
	10:140
140:                nextLine = sr.ReadLine();
141:        static int PARENT = -100;
142:
	0:143
	1:146
	2:150
	3:154
	4:156
	5:158
	6:160
	7:162
	8:164
	9:166
	10:168
143:
	1:144
144:
	10:145
145:                        {
146:
	1:147
	10:149
147:
	10:148
148:        {
149:                case -1:
150:
	1:151
	10:153
151:
	10:152
152:            {
153:                case -3:
154:
	10:155
155:
156:
	10:157
157:        public DecTree<E> TGet(long address)
158:
	10:159
159:            return hashValue;
160:
	10:161
161:            {
162:
	10:163
163:            fs.Dispose();
164:
	10:165
165:                                ds.AddChar(nextLine[i]);
166:
	10:167
167:            DecTree<DecTree<string>> holderTree = new DecTree<DecTree<string>>();
168:
169:
	0:170
	1:173
	2:177
	3:181
	4:183
	5:185
	6:187
	7:189
	8:191
	9:193
	10:195
170:
	1:171
171:
	10:172
172:                            ds.AddChar(nextLine[i]);
173:
	1:174
	10:176
174:
	10:175
175:        /*
176:                        opTree = this.dtC;
177:
	1:178
	10:180
178:
	10:179
179:            }
180:
181:
	10:182
182:                    longAddress *= -1;
183:
	10:184
184:        }
185:
	10:186
186:                primes.Add(0, 2);
187:
	10:188
188:
189:
	10:190
190:
191:
	10:192
192:                            ds.AddChar(nextLine[i]);
193:
	10:194
194:                {
195:            {
196:
	0:197
	1:200
	2:204
	3:208
	4:210
	5:212
	6:214
	7:216
	8:218
	9:220
	10:222
197:
	1:198
198:
	10:199
199:                        }
200:
	1:201
	10:203
201:
	10:202
202:            {
203:
204:
	1:205
	10:207
205:
	10:206
206:        {
207:            DecTree<E> retTree = this;
208:
	10:209
209:            catch (NullReferenceException)
210:
	10:211
211:            {
212:
	10:213
213:                for (long j = 0; j <= primes.counter; j++)
214:
	10:215
215:                order[9] = currTree.dt9;
216:
	10:217
217:                    nextLine = sr.ReadLine();
218:
	10:219
219:                        }
220:
	10:221
221:                    for (; nextLine[i] > 0x2f && nextLine[i] < 0x3a; i++)
222:            this.counter++;
223:
	0:224
	1:227
	2:231
	3:235
	4:237
	5:239
	6:241
	7:243
	8:245
	9:247
	10:249
224:
	1:225
225:
	10:226
226:                        currDecTree.dt5 = holderTree.Get(Int64.Parse(ds.ToString()));
227:
	1:228
	10:230
228:
	10:229
229:            }
230:        public DecTree<E> GetDecTree(int type)
231:
	1:232
	10:234
232:
	10:233
233:        {//because this is a wrapper class
234:            while ((int)address > 0)
235:
	10:236
236:            retPair.Depth = 0;
237:
	10:238
238:        public bool Rm(long address)
239:
	10:240
240:                    else
241:
	10:242
242:            }
243:
	10:244
244:                    {
245:
	10:246
246:                        currDecTree.dt4 = holderTree.Get(Int64.Parse(ds.ToString()));
247:
	10:248
248:                    }
249:            switch (type)
250:
	0:251
	1:254
	2:258
	3:262
	4:264
	5:266
	6:268
	7:270
	8:272
	9:274
	10:276
251:
	1:252
252:
	10:253
253:                        ds.Clear();
254:
	1:255
	10:257
255:
	10:256
256:            {
257:                    }
258:
	1:259
	10:261
259:
	10:260
260:        }
261:        public DecTree<E> PaveTo(String address)
262:
	10:263
263:            return retPair;
264:
	10:265
265:        }
266:
	10:267
267:            return primes.Get(index);
268:
	10:269
269:            foreach (DecTree<E> member in order)
270:
	10:271
271:                    string element = ds.ToString();
272:
	10:273
273:                        ds.Clear();
274:
	10:275
275:            sr.Close();
276:                    {
277:
	0:278
	1:306
	2:335
	3:364
	4:391
	5:418
	6:445
	7:472
	8:499
	9:526
	10:553
278:
	0:279
	1:282
	2:286
	3:290
	4:294
	5:296
	6:298
	7:300
	8:302
	9:304
279:
	1:280
280:
	10:281
281:                the index is already set from the else case.
282:
	1:283
	10:285
283:
	10:284
284:                    else if (nextLine[1] == '8')
285:                    }
286:
	1:287
	10:289
287:
	10:288
288:            }
289:                        break;
290:
	1:291
	10:293
291:
	10:292
292:        public static DecTime Convert(DateTime present)
293:            {
294:
	10:295
295:        }
296:
	10:297
297:            }
298:
	10:299
299:                    member.serializationCounter = referenceHolder.counter;
300:
	10:301
301:                DecTree<E> currTree = referenceHolder.Get(i);
302:
	10:303
303:            //close then reopen the file so we can read agan from beginning.
304:
	10:305
305:                    else if (nextLine[1] == '7')
306:
	0:307
	1:310
	2:314
	3:318
	4:322
	5:324
	6:326
	7:328
	8:330
	9:332
	10:334
307:
	1:308
308:
	10:309
309:                        {
310:
	1:311
	10:313
311:
	10:312
312:                    {
313:                        this.dt4 ??= new DecTree<E>(FOUR);
314:
	1:315
	10:317
315:
	10:316
316:        public override String ToString()
317:                        opTree = this.dt4;
318:
	1:319
	10:321
319:
	10:320
320:        public int Depth { get; set; }
321:            return retTree;
322:
	10:323
323:            {
324:
	10:325
325:                {
326:
	10:327
327:        /// <returns>the count</returns>
328:
	10:329
329:                }
330:
	10:331
331:                We get the tree with that index, find the identities
332:
	10:333
333:                    {
334:        public DecTree<E> dt3;
335:
	0:336
	1:339
	2:343
	3:347
	4:351
	5:353
	6:355
	7:357
	8:359
	9:361
	10:363
336:
	1:337
337:
	10:338
338:                            for (int i = 3; i < nextLine.Length; i++)
339:
	1:340
	10:342
340:
	10:341
341:                //parse for index, find it, store in index variable.
342:                    }
343:
	1:344
	10:346
344:
	10:345
345:        public void Clear()
346:                case 6:
347:
	1:348
	10:350
348:
	10:349
349:    }
350:                if (address == 0)
351:
	10:352
352:        {
353:
	10:354
354:                counterDecrement();
355:
	10:356
356:                {
357:
	10:358
358:                }
359:
	10:360
360:                            ds.AddChar(nextLine[i]);
361:
	10:362
362:                        for (int i = 3; i < nextLine.Length; i++)
363:        public DecTree<long> primes;
364:
	0:365
	1:368
	2:372
	3:376
	4:378
	5:380
	6:382
	7:384
	8:386
	9:388
	10:390
365:
	1:366
366:
	10:367
367:                            {
368:
	1:369
	10:371
369:
	10:370
370:                nextLine = sr.ReadLine();
371:                    {
372:
	1:373
	10:375
373:
	10:374
374:        /// </summary>
375:                    }
376:
	10:377
377:                {
378:
	10:379
379:        {
380:
	10:381
381:        {
382:
	10:383
383:        /// </summary>
384:
	10:385
385:                order[8] = currTree.dt8;
386:
	10:387
387:                            {
388:
	10:389
389:                {
390:        static int THREE = 3;
391:
	0:392
	1:395
	2:399
	3:403
	4:405
	5:407
	6:409
	7:411
	8:413
	9:415
	10:417
392:
	1:393
393:
	10:394
394:                                ds.AddChar(nextLine[i]);
395:
	1:396
	10:398
396:
	10:397
397:    /// </summary>
398:                    }
399:
	1:400
	10:402
400:
	10:401
401:                return r_tree;
402:                        break;
403:
	10:404
404:            }
405:
	10:406
406:        {
407:
	10:408
408:
409:
	10:410
410:            {
411:
	10:412
412:                        for (int k = 0; k < nextline.Length; k++)
413:
	10:414
414:                                ds.AddChar(nextLine[i]);
415:
	10:416
416:            }
417:
418:
	0:419
	1:422
	2:426
	3:430
	4:432
	5:434
	6:436
	7:438
	8:440
	9:442
	10:444
419:
	1:420
420:
	10:421
421:                            ds.AddChar(nextLine[i]);
422:
	1:423
	10:425
423:
	10:424
424:            chars = new DecTree<char>();
425:                    {
426:
	1:427
	10:429
427:
	10:428
428:                opDString.AddChar(input[charCounter]);
429:                    {
430:
	10:431
431:                long longAddress = Hasher(0, address);
432:
	10:433
433:        {
434:
	10:435
435:        }
436:
	10:437
437:                DecTree<E> currTree = referenceHolder.Get(i);
438:
	10:439
439:        }
440:
	10:441
441:                            }
442:
	10:443
443:
444:        public DecTree(E element)
445:
	0:446
	1:449
	2:453
	3:457
	4:459
	5:461
	6:463
	7:465
	8:467
	9:469
	10:471
446:
	1:447
447:
	10:448
448:                        }
449:
	1:450
	10:452
450:
	10:451
451:        
452:                        break;
453:
	1:454
	10:456
454:
	10:455
455:            if (input[input.Length - 1] != ' ')
456:                default:
457:
	10:458
458:                }
459:
	10:460
460:
461:
	10:462
462:            }
463:
	10:464
464:                order[0] = currTree.dt0;
465:
	10:466
466:            StreamReader sr = new StreamReader(path);
467:
	10:468
468:                        }
469:
	10:470
470:                    nextLine = sr.ReadLine();
471:                this.dtP.counterDecrement();
472:
	0:473
	1:476
	2:480
	3:484
	4:486
	5:488
	6:490
	7:492
	8:494
	9:496
	10:498
473:
	1:474
474:
	10:475
475:                        currDecTree.dt4 = holderTree.Get(Int64.Parse(ds.ToString()));
476:
	1:477
	10:479
477:
	10:478
478:                chars.Rm(--Length);
479:                default:
480:
	1:481
	10:483
481:
	10:482
482:            return (chars.Length() == this.Length);
483:            if (address == 0)
484:
	10:485
485:            {
486:
	10:487
487:                this.dtC = null;
488:
	10:489
489:                {
490:
	10:491
491:                order[10] = currTree.dtC;
492:
	10:493
493:                    continue;
494:
	10:495
495:                        currDecTree.dt3 = holderTree.Get(Int64.Parse(ds.ToString()));
496:
	10:497
497:                    {
498:            if (this.dtP != null)
499:
	0:500
	1:503
	2:507
	3:511
	4:513
	5:515
	6:517
	7:519
	8:521
	9:523
	10:525
500:
	1:501
501:
	10:502
502:                        ds.Clear();
503:
	1:504
	10:506
504:
	10:505
505:            else
506:        {
507:
	1:508
	10:510
508:
	10:509
509:            actualDate = present;
510:            // TODO: I kind of want to parse left to right but I don't want to sacrifice the runtime.
511:
	10:512
512:            while (opTree.dtC != null)
513:
	10:514
514:        {
515:
	10:516
516:                    {
517:
	10:518
518:            return retString.ToString();
519:
	10:520
520:                        ds.AddChar(nextLine[i]);
521:
	10:522
522:                        ds.Clear();
523:
	10:524
524:                    string element = ds.ToString();
525:            {
526:
	0:527
	1:530
	2:534
	3:538
	4:540
	5:542
	6:544
	7:546
	8:548
	9:550
	10:552
527:
	1:528
528:
	10:529
529:                    }
530:
	1:531
	10:533
531:
	10:532
532:                AddChar(starter[i]);
533:
534:
	1:535
	10:537
535:
	10:536
536:        public static DecTime Parse(string input)
537:        {
538:
	10:539
539:        }
540:
	10:541
541:
542:
	10:543
543:        }
544:
	10:545
545:            {
546:
	10:547
547:                    ds.Clear();
548:
	10:549
549:                    }
550:
	10:551
551:            sr = new StreamReader(path);
552:                        this.dt1 ??= new DecTree<E>(ONE);
553:using System.IO;
554:
	0:555
	1:583
	2:612
	3:641
	4:668
	5:695
	6:722
	7:749
	8:776
	9:803
	10:830
555:
	0:556
	1:559
	2:563
	3:567
	4:571
	5:573
	6:575
	7:577
	8:579
	9:581
556:
	1:557
557:
	10:558
558:                We get the tree with that index, find the identities
559:
	1:560
	10:562
560:
	10:561
561:                    {
562:
563:
	1:564
	10:566
564:
	10:565
565:        }
566:                    }
567:
	1:568
	10:570
568:
	10:569
569:        {//another wrapping joke
570:                retTree = retTree.MakeDecTree(NEGATIVE);
571:
	10:572
572:
573:
	10:574
574:        }
575:
	10:576
576:                    member.CollectSubTrees(referenceHolder);
577:
	10:578
578:                if (currTree.element == null)
579:
	10:580
580:            nextLine = sr.ReadLine();
581:
	10:582
582:                    {
583:
	0:584
	1:587
	2:591
	3:595
	4:599
	5:601
	6:603
	7:605
	8:607
	9:609
	10:611
584:
	1:585
585:
	10:586
586:                            ds.AddChar(nextLine[i]);
587:
	1:588
	10:590
588:
	10:589
589:                        for (int i = 3; i < nextLine.Length; i++)
590:                        opTree = this.dt4;
591:
	1:592
	10:594
592:
	10:593
593:        {
594:                        break;
595:
	1:596
	10:598
596:
	10:597
597:    }
598:        }
599:
	10:600
600:                return this.GoGet(address).dtC;
601:
	10:602
602:                    return false;
603:
	10:604
604:        public long Length()
605:
	10:606
606:                else
607:
	10:608
608:                of the subordinate DecTrees, and properly assign
609:
	10:610
610:                        for (int i = 3; i < nextLine.Length; i++)
611:        public DecTree<E> dt4;
612:
	0:613
	1:616
	2:620
	3:624
	4:628
	5:630
	6:632
	7:634
	8:636
	9:638
	10:640
613:
	1:614
614:
	10:615
615:                            {
616:
	1:617
	10:619
617:
	10:618
618:                {
619:
620:
	1:621
	10:623
621:
	10:622
622:        {
623:                    {
624:
	1:625
	10:627
625:
	10:626
626:}
627:                {
628:
	10:629
629:            return this.GoGet(address).Get();
630:
	10:631
631:                return true;
632:
	10:633
633:                    return i;
634:
	10:635
635:
636:
	10:637
637:                        }
638:
	10:639
639:                        {
640:        public E element = default(E);
641:
	0:642
	1:645
	2:649
	3:653
	4:655
	5:657
	6:659
	7:661
	8:663
	9:665
	10:667
642:
	1:643
643:
	10:644
644:                                ds.AddChar(nextLine[i]);
645:
	1:646
	10:648
646:
	10:647
647:            }
648:                        this.dt7 ??= new DecTree<E>(SEVEN);
649:
	1:650
	10:652
650:
	10:651
651:        /// <param name="input">the string to be split.</param>
652:                case 8:
653:
	10:654
654:                    int mod = (int)address % 10;
655:
	10:656
656:            DecTree<E> opTree = this.PaveTo(address);
657:
	10:658
658:            try
659:
	10:660
660:        /// <returns></returns>
661:
	10:662
662:                order[9] = currTree.dt9;
663:
	10:664
664:                                ds.AddChar(nextLine[i]);
665:
	10:666
666:                    int i = 0;
667:        static int FOUR = 4;
668:
	0:669
	1:672
	2:676
	3:680
	4:682
	5:684
	6:686
	7:688
	8:690
	9:692
	10:694
669:
	1:670
670:
	10:671
671:                            }
672:
	1:673
	10:675
673:
	10:674
674:    class DecString
675:
676:
	1:677
	10:679
677:
	10:678
678:            }
679:                    }
680:
	10:681
681:        }
682:
	10:683
683:            DecTree<E> opTree = this.PaveTo(Hasher(0, address));
684:
	10:685
685:
686:
	10:687
687:                if (member != null)
688:
	10:689
689:                        {
690:
	10:691
691:                            }
692:
	10:693
693:            sr.Dispose();
694:        /* used to Make Type-Specific DecTrees*/
695:
	0:696
	1:699
	2:703
	3:707
	4:709
	5:711
	6:713
	7:715
	8:717
	9:719
	10:721
696:
	1:697
697:
	10:698
698:                        }
699:
	1:700
	10:702
700:
	10:701
701:            Length = 0;
702:                        this.dtN ??= new DecTree<E>(NEGATIVE);
703:
	1:704
	10:706
704:
	10:705
705:                charCounter++;
706:                        opTree = this.dtC;
707:
	10:708
708:
709:
	10:710
710:            try
711:
	10:712
712:
713:
	10:714
714:                if (currTree.element == null)
715:
	10:716
716:
717:
	10:718
718:                            currDecTree.dtN = holderTree.Get(Int64.Parse(ds.ToString()));
719:
	10:720
720:            StreamReader sr = new StreamReader(path);
721:        {
722:
	0:723
	1:726
	2:730
	3:734
	4:736
	5:738
	6:740
	7:742
	8:744
	9:746
	10:748
723:
	1:724
724:
	10:725
725:                        currDecTree.dt3 = holderTree.Get(Int64.Parse(ds.ToString()));
726:
	1:727
	10:729
727:
	10:728
728:        */
729:                    }
730:
	1:731
	10:733
731:
	10:732
732:            {
733:                    opTree = null;
734:
	10:735
735:                else while (longAddress > 0)
736:
	10:737
737:        public bool Rm()
738:
	10:739
739:
740:
	10:741
741:                order[1] = currTree.dt1;
742:
	10:743
743:            DecString ds = new DecString();
744:
	10:745
745:                        currDecTree.dt2 = holderTree.Get(Int64.Parse(ds.ToString()));
746:
	10:747
747:                    continue;
748:            }
749:
	0:750
	1:753
	2:757
	3:761
	4:763
	5:765
	6:767
	7:769
	8:771
	9:773
	10:775
750:
	1:751
751:
	10:752
752:                        ds.Clear();
753:
	1:754
	10:756
754:
	10:755
755:            }
756:                    opTree = null;
757:
	1:758
	10:760
758:
	10:759
759:        }
760:            {
761:
	10:762
762:                return default(DecTree<E>);
763:
	10:764
764:                this.element = default(E);
765:
	10:766
766:                    if (primes.counter >= index)
767:
	10:768
768:                order[11] = currTree.dtN;
769:
	10:770
770:                }
771:
	10:772
772:                        ds.Clear();
773:
	10:774
774:                        ds.AddChar(nextLine[i]);
775:            {
776:
	0:777
	1:780
	2:784
	3:788
	4:790
	5:792
	6:794
	7:796
	8:798
	9:800
	10:802
777:
	1:778
778:
	10:779
779:                    }
780:
	1:781
	10:783
781:
	10:782
782:            {
783:            DecTree<E> opTree;
784:
	1:785
	10:787
785:
	10:786
786:        }
787:            {
788:
	10:789
789:            {
790:
	10:791
791:            try
792:
	10:793
793:                        if (j == primes.counter)
794:
	10:795
795:        }
796:
	10:797
797:                    }
798:
	10:799
799:                    }
800:
	10:801
801:                    ds.Clear();
802:                case 0:
803:
	0:804
	1:807
	2:811
	3:815
	4:817
	5:819
	6:821
	7:823
	8:825
	9:827
	10:829
804:
	1:805
805:
	10:806
806:                    else if (nextLine[1] == '7')
807:
	1:808
	10:810
808:
	10:809
809:            }
810:                case 1:
811:
	1:812
	10:814
812:
	10:813
813:        {
814:            DecTree<E> retTree = this;
815:
	10:816
816:
817:
	10:818
818:        public bool Rm(String address)
819:
	10:820
820:
821:
	10:822
822:                if (member != null)
823:
	10:824
824:
825:
	10:826
826:                    else if (nextLine[1] == '6')
827:
	10:828
828:            //close then reopen the file so we can read agan from beginning.
829:                        opTree = this.dt1;
830:
831:
	0:832
	1:860
	2:889
	3:916
	4:943
	5:970
	6:997
	7:1024
	8:1051
	9:1078
	10:1105
832:
	0:833
	1:836
	2:840
	3:844
	4:848
	5:850
	6:852
	7:854
	8:856
	9:858
833:
	1:834
834:
	10:835
835:                of the subordinate DecTrees, and properly assign
836:
	1:837
	10:839
837:
	10:838
838:                        for (int i = 3; i < nextLine.Length; i++)
839:                case 3:
840:
	1:841
	10:843
841:
	10:842
842:
843:
844:
	1:845
	10:847
845:
	10:846
846:            return new DecTime(present);
847:                longAddress *= -1;
848:
	10:849
849:        public E Get()
850:
	10:851
851:
852:
	10:853
853:                }
854:
	10:855
855:                {
856:
	10:857
857:            DecTree<object> currDecTree;
858:
	10:859
859:                        for (int i = 3; i < nextLine.Length; i++)
860:
	0:861
	1:864
	2:868
	3:872
	4:876
	5:878
	6:880
	7:882
	8:884
	9:886
	10:888
861:
	1:862
862:
	10:863
863:                        }
864:
	1:865
	10:867
865:
	10:866
866:                        {
867:                        break;
868:
	1:869
	10:871
869:
	10:870
870:            char[] allChars = new char[this.Length];
871:                    }
872:
	1:873
	10:875
873:
	10:874
874:
875:
876:
	10:877
877:            }
878:
	10:879
879:                }
880:
	10:881
881:        {
882:
	10:883
883:                {
884:
	10:885
885:                the references according to {0-9 : dt0-dt9, 10->dtC,
886:
	10:887
887:                        {
888:        public DecTree<E> dt5;
889:
	0:890
	1:893
	2:897
	3:901
	4:903
	5:905
	6:907
	7:909
	8:911
	9:913
	10:915
890:
	1:891
891:
	10:892
892:                                ds.AddChar(nextLine[i]);
893:
	1:894
	10:896
894:
	10:895
895:                    int i = 0;
896:                case 6:
897:
	1:898
	10:900
898:
	10:899
899:            chars = new DecTree<char>();
900:                        opTree = this.dt6;
901:
	10:902
902:                    return this;
903:
	10:904
904:        }
905:
	10:906
906:            }
907:
	10:908
908:                }
909:
	10:910
910:                order[0] = currTree.dt0;
911:
	10:912
912:                        currDecTree.dt0 = holderTree.Get(Int64.Parse(ds.ToString()));
913:
	10:914
914:                            ds.AddChar(nextLine[i]);
915:
916:
	0:917
	1:920
	2:924
	3:928
	4:930
	5:932
	6:934
	7:936
	8:938
	9:940
	10:942
917:
	1:918
918:
	10:919
919:                            }
920:
	1:921
	10:923
921:
	10:922
922:            sr.Dispose();
923:                        opTree = this.dt7;
924:
	1:925
	10:927
925:
	10:926
926:        /// <returns></returns>
927:                    {
928:
	10:929
929:                    address /= 10;
930:
	10:931
931:            while (opTree.dtC != null)
932:
	10:933
933:            {
934:
	10:935
935:        public override string ToString()
936:
	10:937
937:                order[10] = currTree.dtC;
938:
	10:939
939:                            }
940:
	10:941
941:                    for (; nextLine[i] > 0x2f && nextLine[i] < 0x3a; i++)
942:        static int FIVE = 5;
943:
	0:944
	1:947
	2:951
	3:955
	4:957
	5:959
	6:961
	7:963
	8:965
	9:967
	10:969
944:
	1:945
945:
	10:946
946:                            currDecTree.dtN = holderTree.Get(Int64.Parse(ds.ToString()));
947:
	1:948
	10:950
948:
	10:949
949:    {
950:                case 9:
951:
	1:952
	10:954
952:
	10:953
953:
954:
955:
	10:956
956:
957:
	10:958
958:            while (opTree.dtC != null)
959:
	10:960
960:        public long Hasher(long zero, string tag)
961:
	10:962
962:                {
963:
	10:964
964:                            nextline_bytes[k] = (byte)nextline[k];
965:
	10:966
966:                            currDecTree.dtC = holderTree.Get(Int64.Parse(ds.ToString()));
967:
	10:968
968:            return holderTree.Get(0);
969:        public DecTree()
970:
	0:971
	1:974
	2:978
	3:982
	4:984
	5:986
	6:988
	7:990
	8:992
	9:994
	10:996
971:
	1:972
972:
	10:973
973:                        currDecTree.dt2 = holderTree.Get(Int64.Parse(ds.ToString()));
974:
	1:975
	10:977
975:
	10:976
976:        }
977:                        opTree = this.dtN;
978:
	1:979
	10:981
979:
	10:980
980:                if (input[charCounter] == ' ')
981:                        break;
982:
	10:983
983:                if (longAddress == 0)
984:
	10:985
985:            {
986:
	10:987
987:        // Level 0
988:
	10:989
989:                {
990:
	10:991
991:        /**
992:
	10:993
993:                            ds.Clear();
994:
	10:995
995:            DecString ds = new DecString();
996:            this.element = element;
997:
	0:998
	1:1001
	2:1005
	3:1009
	4:1011
	5:1013
	6:1015
	7:1017
	8:1019
	9:1021
	10:1023
998:
	1:999
999:
	10:1000
1000:                        ds.Clear();
1001:
	1:1002
	10:1004
1002:
	10:1003
1003:        public void RmChar()
1004:
1005:
	1:1006
	10:1008
1006:
	10:1007
1007:                r_tree1.Add(stringIndex, opDString);
1008:                    break;
1009:
	10:1010
1010:                    {
1011:
	10:1012
1012:        {
1013:
	10:1014
1014:            //can see how many times this method has been this.primes with primes.TGet(0) analysis.
1015:
	10:1016
1016:                order[2] = currTree.dt2;
1017:
	10:1018
1018:            string nextLine = sr.ReadLine();
1019:
	10:1020
1020:                        ds.Clear();
1021:
	10:1022
1022:                }
1023:        }
1024:
	0:1025
	1:1028
	2:1032
	3:1036
	4:1038
	5:1040
	6:1042
	7:1044
	8:1046
	9:1048
	10:1050
1025:
	1:1026
1026:
	10:1027
1027:                    }
1028:
	1:1029
	10:1031
1029:
	10:1030
1030:        }
1031:                    break;
1032:
	1:1033
	10:1035
1033:
	10:1034
1034:#pragma warning restore 168
1035:                return this;
1036:
	10:1037
1037:            }
1038:
	10:1039
1039:                return true;
1040:
	10:1041
1041:                    {
1042:
	10:1043
1043:                for (int j = 0; j < order.Length; j++)
1044:
	10:1045
1045:                else
1046:
	10:1047
1047:                    }
1048:
	10:1049
1049:                    }
1050:                this.dtP.counterIncrement();
1051:
	0:1052
	1:1055
	2:1059
	3:1063
	4:1065
	5:1067
	6:1069
	7:1071
	8:1073
	9:1075
	10:1077
1052:
	1:1053
1053:
	10:1054
1054:                    else if (nextLine[1] == '6')
1055:
	1:1056
	10:1058
1056:
	10:1057
1057:                return EndOfLine;
1058:
1059:
	1:1060
	10:1062
1060:
	10:1061
1061:
1062:                int mod = (int)address % 10;
1063:
	10:1064
1064:                opTree = opTree.dtC;
1065:
	10:1066
1066:            {
1067:
	10:1068
1068:                        {
1069:
	10:1070
1070:
1071:
	10:1072
1072:                    index = Int64.Parse(ds.ToString());
1073:
	10:1074
1074:                    else if (nextLine[1] == '5')
1075:
	10:1076
1076:
1077:                    {
1078:
	0:1079
	1:1082
	2:1086
	3:1090
	4:1092
	5:1094
	6:1096
	7:1098
	8:1100
	9:1102
	10:1104
1079:
	1:1080
1080:
	10:1081
1081:                    {
1082:
	1:1083
	10:1085
1083:
	10:1084
1084:        }
1085:                    {
1086:
	1:1087
	10:1089
1087:
	10:1088
1088:            return new DecTime(DateTime.Parse(input));
1089:
1090:
	10:1091
1091:        public DecPair<E> Add(long address, E element)
1092:
	10:1093
1093:        {
1094:
	10:1095
1095:        public DecTree<DecTree<E>> CollectSubTrees(DecTree<DecTree<E>> referenceHolder)
1096:
	10:1097
1097:                {
1098:
	10:1099
1099:                    holderTree.Add(index, new DecTree<object>(refObject.FromString(element)));
1100:
	10:1101
1101:                    {
1102:
	10:1103
1103:            nextLine = sr.ReadLine();
1104:                        break;
1105:namespace Dec
1106:
	0:1107
	1:1135
	2:1164
	3:1191
	4:1218
	5:1245
	6:1272
	7:1299
	8:1326
	9:1353
	10:1380
1107:
	0:1108
	1:1111
	2:1115
	3:1119
	4:1123
	5:1125
	6:1127
	7:1129
	8:1131
	9:1133
1108:
	1:1109
1109:
	10:1110
1110:                the references according to {0-9 : dt0-dt9, 10->dtC,
1111:
	1:1112
	10:1114
1112:
	10:1113
1113:                        {
1114:                    {
1115:
	1:1116
	10:1118
1116:
	10:1117
1117:        public DecString(String init)
1118:                case 3:
1119:
	1:1120
	10:1122
1120:
	10:1121
1121:        }
1122:            }
1123:
	10:1124
1124:        {
1125:
	10:1126
1126:        public bool RmL()
1127:
	10:1128
1128:            }
1129:
	10:1130
1130:                    char[] nextline = $"{i}:\n".ToCharArray();
1131:
	10:1132
1132:            index = -1;
1133:
	10:1134
1134:                        {
1135:
	0:1136
	1:1139
	2:1143
	3:1147
	4:1151
	5:1153
	6:1155
	7:1157
	8:1159
	9:1161
	10:1163
1136:
	1:1137
1137:
	10:1138
1138:                        currDecTree.dt0 = holderTree.Get(Int64.Parse(ds.ToString()));
1139:
	1:1140
	10:1142
1140:
	10:1141
1141:                            ds.AddChar(nextLine[i]);
1142:                    }
1143:
	1:1144
	10:1146
1144:
	10:1145
1145:            for (int i = 0; i < this.Length; i++)
1146:
1147:
	1:1148
	10:1150
1148:
	10:1149
1149:    public abstract class ConvertibleObject
1150:        public DecTree<E> GoGet(long address)
1151:
	10:1152
1152:            catch (NullReferenceException)
1153:
	10:1154
1154:                ChildTree = FocusTree.dtC;
1155:
	10:1156
1156:            for (long i = 0; true; i++)
1157:
	10:1158
1158:                    char[] nextline = $"{i}:{currTree.element.ToString()}\n".ToCharArray();
1159:
	10:1160
1160:                11->dtN*/
1161:
	10:1162
1162:                            ds.AddChar(nextLine[i]);
1163:        public DecTree<E> dt6;
1164:
	0:1165
	1:1168
	2:1172
	3:1176
	4:1178
	5:1180
	6:1182
	7:1184
	8:1186
	9:1188
	10:1190
1165:
	1:1166
1166:
	10:1167
1167:                            }
1168:
	1:1169
	10:1171
1169:
	10:1170
1170:                    for (; nextLine[i] > 0x2f && nextLine[i] < 0x3a; i++)
1171:                    {
1172:
	1:1173
	10:1175
1173:
	10:1174
1174:            Length = 0;
1175:                        break;
1176:
	10:1177
1177:                }
1178:
	10:1179
1179:
1180:
	10:1181
1181:            catch (NullReferenceException)
1182:
	10:1183
1183:            }
1184:
	10:1185
1185:                order[1] = currTree.dt1;
1186:
	10:1187
1187:                        ds.Clear();
1188:
	10:1189
1189:                        }
1190:        long type = 0;
1191:
	0:1192
	1:1195
	2:1199
	3:1203
	4:1205
	5:1207
	6:1209
	7:1211
	8:1213
	9:1215
	10:1217
1192:
	1:1193
1193:
	10:1194
1194:                            currDecTree.dtC = holderTree.Get(Int64.Parse(ds.ToString()));
1195:
	1:1196
	10:1198
1196:
	10:1197
1197:            return holderTree.Get(0);
1198:                        break;
1199:
	1:1200
	10:1202
1200:
	10:1201
1201:        public static DecTree<DecString> Split(string input)
1202:                        opTree = this.dt8;
1203:
	10:1204
1204:                    opTree = opTree.GetDecTree(mod);
1205:
	10:1206
1206:            {
1207:
	10:1208
1208:                return this.GoGet(address).RmL();
1209:
	10:1210
1210:        //If you make changes, ensure that you amend FromString
1211:
	10:1212
1212:                order[11] = currTree.dtN;
1213:
	10:1214
1214:                            currDecTree.dt1 = holderTree.Get(Int64.Parse(ds.ToString()));
1215:
	10:1216
1216:                    {
1217:        static int SIX = 6;
1218:
	0:1219
	1:1222
	2:1226
	3:1230
	4:1232
	5:1234
	6:1236
	7:1238
	8:1240
	9:1242
	10:1244
1219:
	1:1220
1220:
	10:1221
1221:                            ds.Clear();
1222:
	1:1223
	10:1225
1223:
	10:1224
1224:        private DecTree<char> chars;
1225:                    {
1226:
	1:1227
	10:1229
1227:
	10:1228
1228:            int stringIndex = 0;
1229:                case -1:
1230:
	10:1231
1231:        public DecTree<E> GoGet(String address)
1232:
	10:1233
1233:            {
1234:
	10:1235
1235:        {
1236:
	10:1237
1237:                    referenceHolder.Add(++referenceHolder.counter, member);
1238:
	10:1239
1239:                        }
1240:
	10:1241
1241:                            ds.Clear();
1242:
	10:1243
1243:            /*return *.Get(0) because the base tree has id 0.
1244:        {
1245:
	0:1246
	1:1249
	2:1253
	3:1257
	4:1259
	5:1261
	6:1263
	7:1265
	8:1267
	9:1269
	10:1271
1246:
	1:1247
1247:
	10:1248
1248:                        ds.Clear();
1249:
	1:1250
	10:1252
1250:
	10:1251
1251:
1252:                        break;
1253:
	1:1254
	10:1256
1254:
	10:1255
1255:                {
1256:                    }
1257:
	10:1258
1258:                {
1259:
	10:1260
1260:                return this.PaveTo(address).dtC;
1261:
	10:1262
1262:        public long Prime(long index)
1263:
	10:1264
1264:                    retString.AddString($"{i}:\n");
1265:
	10:1266
1266:            Imports from file, but converts all types from string to I using reference object's FromString method.
1267:
	10:1268
1268:                        }
1269:
	10:1270
1270:            string nextLine = sr.ReadLine();
1271:        }
1272:
	0:1273
	1:1276
	2:1280
	3:1284
	4:1286
	5:1288
	6:1290
	7:1292
	8:1294
	9:1296
	10:1298
1273:
	1:1274
1274:
	10:1275
1275:                    }
1276:
	1:1277
	10:1279
1277:
	10:1278
1278:        {
1279:                case -100:
1280:
	1:1281
	10:1283
1281:
	10:1282
1282:            }
1283:
1284:
	10:1285
1285:                        int mod = (int)longAddress % 10;
1286:
	10:1287
1287:            if (this.dtC != null && this.dtC.dtC != null)
1288:
	10:1289
1289:            for (long i = primes.Get(primes.counter) + 1; i < primes.Get(primes.counter) * 2; i++)
1290:
	10:1291
1291:                order[3] = currTree.dt3;
1292:
	10:1293
1293:            long index = -1;
1294:
	10:1295
1295:                    }
1296:
	10:1297
1297:                else
1298:
1299:
	0:1300
	1:1303
	2:1307
	3:1311
	4:1313
	5:1315
	6:1317
	7:1319
	8:1321
	9:1323
	10:1325
1300:
	1:1301
1301:
	10:1302
1302:                    else if (nextLine[1] == '5')
1303:
	1:1304
	10:1306
1304:
	10:1305
1305:
1306:
1307:
	1:1308
	10:1310
1308:
	10:1309
1309:    }
1310:            }
1311:
	10:1312
1312:        }
1313:
	10:1314
1314:            }
1315:
	10:1316
1316:                        break;
1317:
	10:1318
1318:                {
1319:
	10:1320
1320:                /*The only other case is for the line to begin with an index.
1321:
	10:1322
1322:                    else if (nextLine[1] == '4')
1323:
	10:1324
1324:                    index = Int64.Parse(ds.ToString());
1325:            }
1326:
	0:1327
	1:1330
	2:1334
	3:1338
	4:1340
	5:1342
	6:1344
	7:1346
	8:1348
	9:1350
	10:1352
1327:
	1:1328
1328:
	10:1329
1329:                    {
1330:
	1:1331
	10:1333
1331:
	10:1332
1332:            }
1333:            switch (type)
1334:
	1:1335
	10:1337
1335:
	10:1336
1336:        public override DecTime FromString(string input)
1337:                address /= 10;
1338:
	10:1339
1339:                retPair.Depth++;
1340:
	10:1341
1341:                return this.GoGet(address).Rm();
1342:
	10:1343
1343:                            primes.Add(++primes.counter, i);
1344:
	10:1345
1345:        public void Export(string path)
1346:
	10:1347
1347:                    ds.Clear();
1348:
	10:1349
1349:                    {
1350:
	10:1351
1351:                    holderTree.Add(index, new DecTree<string>(element));
1352:                        this.dt0 ??= new DecTree<E>(ZERO);
1353:
	0:1354
	1:1357
	2:1361
	3:1365
	4:1367
	5:1369
	6:1371
	7:1373
	8:1375
	9:1377
	10:1379
1354:
	1:1355
1355:
	10:1356
1356:                        for (int i = 3; i < nextLine.Length; i++)
1357:
	1:1358
	10:1360
1358:
	10:1359
1359:
1360:                        opTree = this.dt1;
1361:
	1:1362
	10:1364
1362:
	10:1363
1363:        }
1364:            long longAddress = Hasher(0, address);
1365:
	10:1366
1366:        {
1367:
	10:1368
1368:            try
1369:
	10:1370
1370:        {
1371:
	10:1372
1372:                    referenceHolder.Add(++referenceHolder.counter, member);
1373:
	10:1374
1374:                }
1375:
	10:1376
1376:                        for (int i = 3; i < nextLine.Length; i++)
1377:
	10:1378
1378:            DecTree<string> currDecTree;
1379:                    }
1380:{
1381:
	0:1382
	1:1410
	2:1439
	3:1466
	4:1493
	5:1520
	6:1547
	7:1574
	8:1601
	9:1628
	10:1655
1382:
	0:1383
	1:1386
	2:1390
	3:1394
	4:1398
	5:1400
	6:1402
	7:1404
	8:1406
	9:1408
1383:
	1:1384
1384:
	10:1385
1385:                11->dtN*/
1386:
	1:1387
	10:1389
1387:
	10:1388
1388:                            ds.AddChar(nextLine[i]);
1389:                        this.dt3 ??= new DecTree<E>(THREE);
1390:
	1:1391
	10:1393
1391:
	10:1392
1392:        {
1393:                    {
1394:
	1:1395
	10:1397
1395:
	10:1396
1396:
1397:            while ((int)longAddress > 0)
1398:
	10:1399
1399:            return this.dtC.element;
1400:
	10:1401
1401:        {
1402:
	10:1403
1403:            return referenceHolder;
1404:
	10:1405
1405:                    byte[] nextline_bytes = new byte[nextline.Length];
1406:
	10:1407
1407:            while (nextLine != null)
1408:
	10:1409
1409:                            ds.AddChar(nextLine[i]);
1410:
	0:1411
	1:1414
	2:1418
	3:1422
	4:1426
	5:1428
	6:1430
	7:1432
	8:1434
	9:1436
	10:1438
1411:
	1:1412
1412:
	10:1413
1413:                        ds.Clear();
1414:
	1:1415
	10:1417
1415:
	10:1416
1416:                        }
1417:
1418:
	1:1419
	10:1421
1419:
	10:1420
1420:            {
1421:                case 5:
1422:
	1:1423
	10:1425
1423:
	10:1424
1424:    {
1425:        {
1426:
	10:1427
1427:            {
1428:
	10:1429
1429:                while (ChildTree != null)
1430:
	10:1431
1431:            {
1432:
	10:1433
1433:                    byte[] nextline_bytes = new byte[nextline.Length];
1434:
	10:1435
1435:                {
1436:
	10:1437
1437:                        }
1438:        public DecTree<E> dt7;
1439:
	0:1440
	1:1443
	2:1447
	3:1451
	4:1453
	5:1455
	6:1457
	7:1459
	8:1461
	9:1463
	10:1465
1440:
	1:1441
1441:
	10:1442
1442:                            currDecTree.dt1 = holderTree.Get(Int64.Parse(ds.ToString()));
1443:
	1:1444
	10:1446
1444:
	10:1445
1445:                    {
1446:                        this.dt6 ??= new DecTree<E>(SIX);
1447:
	1:1448
	10:1450
1448:
	10:1449
1449:        }
1450:                    }
1451:
	10:1452
1452:                else if (address < 0)
1453:
	10:1454
1454:        public E Get(string address)
1455:
	10:1456
1456:            {
1457:
	10:1458
1458:        }
1459:
	10:1460
1460:                order[2] = currTree.dt2;
1461:
	10:1462
1462:                    }
1463:
	10:1464
1464:                        currDecTree.dt9 = holderTree.Get(Int64.Parse(ds.ToString()));
1465:        public long counter = 0;
1466:
	0:1467
	1:1470
	2:1474
	3:1478
	4:1480
	5:1482
	6:1484
	7:1486
	8:1488
	9:1490
	10:1492
1467:
	1:1468
1468:
	10:1469
1469:                            ds.Clear();
1470:
	1:1471
	10:1473
1471:
	10:1472
1472:            /*return *.Get(0) because the base tree has id 0.
1473:                    }
1474:
	1:1475
	10:1477
1475:
	10:1476
1476:        {
1477:                        break;
1478:
	10:1479
1479:                }
1480:
	10:1481
1481:                opTree = opTree.dtC;
1482:
	10:1483
1483:            }
1484:
	10:1485
1485:        {
1486:
	10:1487
1487:                for (int j = 0; j < order.Length; j++)
1488:
	10:1489
1489:                            ds.Clear();
1490:
	10:1491
1491:                        ds.AddChar(nextLine[i]);
1492:        static int SEVEN = 7;
1493:
	0:1494
	1:1497
	2:1501
	3:1505
	4:1507
	5:1509
	6:1511
	7:1513
	8:1515
	9:1517
	10:1519
1494:
	1:1495
1495:
	10:1496
1496:                        }
1497:
	1:1498
	10:1500
1498:
	10:1499
1499:        private long Length;
1500:                        this.dt9 ??= new DecTree<E>(NINE);
1501:
	1:1502
	10:1504
1502:
	10:1503
1503:            int charCounter = 0;
1504:                    {
1505:
	10:1506
1506:        {
1507:
	10:1508
1508:                opTree = opTree.dtC;
1509:
	10:1510
1510:            long hashValue = zero;
1511:
	10:1512
1512:                    member.serializationCounter = referenceHolder.counter;
1513:
	10:1514
1514:                        fs.Write(nextline_bytes, 0, nextline.Length);
1515:
	10:1516
1516:                        }
1517:
	10:1518
1518:            It's an axiom.*/
1519:        }
1520:
	0:1521
	1:1524
	2:1528
	3:1532
	4:1534
	5:1536
	6:1538
	7:1540
	8:1542
	9:1544
	10:1546
1521:
	1:1522
1522:
	10:1523
1523:                    }
1524:
	1:1525
	10:1527
1525:
	10:1526
1526:        public void AddChar(char c)
1527:                    }
1528:
	1:1529
	10:1531
1529:
	10:1530
1530:                    r_tree1.Add(stringIndex++, opDString);
1531:                case -100:
1532:
	10:1533
1533:                    return this;
1534:
	10:1535
1535:            }
1536:
	10:1537
1537:        {
1538:
	10:1539
1539:                }
1540:
	10:1541
1541:            Object must implement IDecConvertible (just means that it must have ToString and FromString methods as specified).    
1542:
	10:1543
1543:                    }
1544:
	10:1545
1545:            long index = -1;
1546:
1547:
	0:1548
	1:1551
	2:1555
	3:1559
	4:1561
	5:1563
	6:1565
	7:1567
	8:1569
	9:1571
	10:1573
1548:
	1:1549
1549:
	10:1550
1550:                    else if (nextLine[1] == '4')
1551:
	1:1552
	10:1554
1552:
	10:1553
1553:            if (Length == 0)
1554:                    {
1555:
	1:1556
	10:1558
1556:
	10:1557
1557:            return r_tree1;
1558:            }
1559:
	10:1560
1560:                        longAddress /= 10;
1561:
	10:1562
1562:            {
1563:
	10:1564
1564:            { // if(Bertrand's Postulate) {Infinite Loop}.
1565:
	10:1566
1566:                order[4] = currTree.dt4;
1567:
	10:1568
1568:            while (nextLine != null)
1569:
	10:1570
1570:                    else if (nextLine[1] == '3')
1571:
	10:1572
1572:                /*The only other case is for the line to begin with an index.
1573:        /// <summary>
1574:
	0:1575
	1:1578
	2:1582
	3:1586
	4:1588
	5:1590
	6:1592
	7:1594
	8:1596
	9:1598
	10:1600
1575:
	1:1576
1576:
	10:1577
1577:                    {
1578:
	1:1579
	10:1581
1579:
	10:1580
1580:        public char GetChar(int index)
1581:            }
1582:
	1:1583
	10:1585
1583:
	10:1584
1584:    class DecTime : ConvertibleObject
1585:            if (address < 0)
1586:
	10:1587
1587:
1588:
	10:1589
1589:            {
1590:
	10:1591
1591:                    }
1592:
	10:1593
1593:                    if (order[j] != null)
1594:
	10:1595
1595:                The procedure is to read the index, read the element, store 
1596:
	10:1597
1597:                    {
1598:
	10:1599
1599:                    ds.Clear();
1600:        }
1601:
	0:1602
	1:1605
	2:1609
	3:1613
	4:1615
	5:1617
	6:1619
	7:1621
	8:1623
	9:1625
	10:1627
1602:
	1:1603
1603:
	10:1604
1604:                        for (int i = 3; i < nextLine.Length; i++)
1605:
	1:1606
	10:1608
1606:
	10:1607
1607:        }
1608:            {
1609:
	1:1610
	10:1612
1610:
	10:1611
1611:        {
1612:                retTree = retTree.MakeDecTree(mod);
1613:
	10:1614
1614:
1615:
	10:1616
1616:            }
1617:
	10:1618
1618:                        }
1619:
	10:1620
1620:        {
1621:
	10:1622
1622:                    i++; //to avoid the colon
1623:
	10:1624
1624:                        for (int i = 3; i < nextLine.Length; i++)
1625:
	10:1626
1626:                }
1627:                        opTree = this.dt0;
1628:
	0:1629
	1:1632
	2:1636
	3:1640
	4:1642
	5:1644
	6:1646
	7:1648
	8:1650
	9:1652
	10:1654
1629:
	1:1630
1630:
	10:1631
1631:                        {
1632:
	1:1633
	10:1635
1633:
	10:1634
1634:        public void AddString(DecString starter)
1635:                        break;
1636:
	1:1637
	10:1639
1637:
	10:1638
1638:
1639:
1640:
	10:1641
1641:            return this.PaveTo(address).Add(element);
1642:
	10:1643
1643:            {
1644:
	10:1645
1645:            DecTree<E>[] order = new DecTree<E>[] { dt0, dt1, dt2, dt3, dt4, dt5, dt6, dt7, dt8, dt9, dtC, dtN };
1646:
	10:1647
1647:                    member.serializationCounter = referenceHolder.counter;
1648:
	10:1649
1649:                nextLine = sr.ReadLine();
1650:
	10:1651
1651:                        {
1652:
	10:1653
1653:            index = -1;
1654:
1655:    public class DecTree<E>
1656:
	0:1657
	1:1685
	2:1714
	3:1741
	4:1768
	5:1795
	6:1822
	7:1849
	8:1876
	9:1903
	10:1930
1657:
	0:1658
	1:1661
	2:1665
	3:1669
	4:1673
	5:1675
	6:1677
	7:1679
	8:1681
	9:1683
1658:
	1:1659
1659:
	10:1660
1660:                {
1661:
	1:1662
	10:1664
1662:
	10:1663
1663:                        }
1664:                        opTree = this.dt3;
1665:
	1:1666
	10:1668
1666:
	10:1667
1667:            chars = new DecTree<char>();
1668:                        opTree = this.dt3;
1669:
	1:1670
	10:1672
1670:
	10:1671
1671:    }
1672:            {
1673:
	10:1674
1674:        }
1675:
	10:1676
1676:            try
1677:
	10:1678
1678:        }
1679:
	10:1680
1680:                    for (int j = 0; j < nextline.Length; j++)
1681:
	10:1682
1682:            {
1683:
	10:1684
1684:                        }
1685:
	0:1686
	1:1689
	2:1693
	3:1697
	4:1701
	5:1703
	6:1705
	7:1707
	8:1709
	9:1711
	10:1713
1686:
	1:1687
1687:
	10:1688
1688:                    }
1689:
	1:1690
	10:1692
1690:
	10:1691
1691:                        currDecTree.dt9 = holderTree.Get(Int64.Parse(ds.ToString()));
1692:                case 5:
1693:
	1:1694
	10:1696
1694:
	10:1695
1695:                allChars[i] = chars.Get(i);
1696:                    {
1697:
	1:1698
	10:1700
1698:
	10:1699
1699:        DecTree<object> fields;
1700:            try
1701:
	10:1702
1702:                return default(DecTree<E>);
1703:
	10:1704
1704:                {
1705:
	10:1706
1706:                try
1707:
	10:1708
1708:                    for (int j = 0; j < nextline.Length; j++)
1709:
	10:1710
1710:                    currDecTree = holderTree.Get(index);
1711:
	10:1712
1712:                        currDecTree.dt8 = holderTree.Get(Int64.Parse(ds.ToString()));
1713:        public DecTree<E> dt8;
1714:
	0:1715
	1:1718
	2:1722
	3:1726
	4:1728
	5:1730
	6:1732
	7:1734
	8:1736
	9:1738
	10:1740
1715:
	1:1716
1716:
	10:1717
1717:                            ds.Clear();
1718:
	1:1719
	10:1721
1719:
	10:1720
1720:                        ds.AddChar(nextLine[i]);
1721:                        opTree = this.dt6;
1722:
	1:1723
	10:1725
1723:
	10:1724
1724:
1725:
1726:
	10:1727
1727:                {
1728:
	10:1729
1729:        {
1730:
	10:1731
1731:                return false;
1732:
	10:1733
1733:
1734:
	10:1735
1735:                order[3] = currTree.dt3;
1736:
	10:1737
1737:                    else if (nextLine[1] == '1')
1738:
	10:1739
1739:                        ds.Clear();
1740:        long serializationCounter = 0;
1741:
	0:1742
	1:1745
	2:1749
	3:1753
	4:1755
	5:1757
	6:1759
	7:1761
	8:1763
	9:1765
	10:1767
1742:
	1:1743
1743:
	10:1744
1744:                        }
1745:
	1:1746
	10:1748
1746:
	10:1747
1747:            It's an axiom.*/
1748:                case 8:
1749:
	1:1750
	10:1752
1750:
	10:1751
1751:
1752:                    }
1753:
	10:1754
1754:                return opTree;
1755:
	10:1756
1756:            }
1757:
	10:1758
1758:            catch (NullReferenceException)
1759:
	10:1760
1760:            DecString retString = new DecString();
1761:
	10:1762
1762:                {
1763:
	10:1764
1764:                        }
1765:
	10:1766
1766:                    }
1767:        static int EIGHT = 8;
1768:
	0:1769
	1:1772
	2:1776
	3:1780
	4:1782
	5:1784
	6:1786
	7:1788
	8:1790
	9:1792
	10:1794
1769:
	1:1770
1770:
	10:1771
1771:                    }
1772:
	1:1773
	10:1775
1773:
	10:1774
1774:        //standard string length.
1775:                        opTree = this.dt9;
1776:
	1:1777
	10:1779
1777:
	10:1778
1778:
1779:                        opTree = this.dtN;
1780:
	10:1781
1781:            try
1782:
	10:1783
1783:            }
1784:
	10:1785
1785:            for (int i = 0; i < tag.Length; i++)
1786:
	10:1787
1787:                    member.CollectSubTrees(referenceHolder);
1788:
	10:1789
1789:
1790:
	10:1791
1791:                        else if (nextLine[2] == '1')
1792:
	10:1793
1793:        }
1794:        private DecTree(int type)
1795:
	0:1796
	1:1799
	2:1803
	3:1807
	4:1809
	5:1811
	6:1813
	7:1815
	8:1817
	9:1819
	10:1821
1796:
	1:1797
1797:
	10:1798
1798:                    else if (nextLine[1] == '3')
1799:
	1:1800
	10:1802
1800:
	10:1801
1801:        {
1802:
1803:
	1:1804
	10:1806
1804:
	10:1805
1805:                    //indexing starts at 0 for this reason.
1806:                    {
1807:
	10:1808
1808:                }
1809:
	10:1810
1810:            catch (NullReferenceException)
1811:
	10:1812
1812:            //only want to add once.
1813:
	10:1814
1814:                else
1815:
	10:1816
1816:        **/
1817:
	10:1818
1818:                    else if (nextLine[1] == '2')
1819:
	10:1820
1820:            while (nextLine != null)
1821:        public void counterDecrement()
1822:
	0:1823
	1:1826
	2:1830
	3:1834
	4:1836
	5:1838
	6:1840
	7:1842
	8:1844
	9:1846
	10:1848
1823:
	1:1824
1824:
	10:1825
1825:                    {
1826:
	1:1827
	10:1829
1827:
	10:1828
1828:            {
1829:                        this.dtP ??= new DecTree<E>(PARENT);
1830:
	1:1831
	10:1833
1831:
	10:1832
1832:        }
1833:            return opTree;
1834:
	10:1835
1835:                        opTree = opTree.GetDecTree(mod);
1836:
	10:1837
1837:                this.dtC = this.dtC.dtC;
1838:
	10:1839
1839:                if (primes.counter == index)
1840:
	10:1841
1841:                order[5] = currTree.dt5;
1842:
	10:1843
1843:            {
1844:
	10:1845
1845:                    {
1846:
	10:1847
1847:                The procedure is to read the index, read the element, store 
1848:        /// Trying to figure out how not to break the hasher with this. Unused for now.
1849:
	0:1850
	1:1853
	2:1857
	3:1861
	4:1863
	5:1865
	6:1867
	7:1869
	8:1871
	9:1873
	10:1875
1850:
	1:1851
1851:
	10:1852
1852:                        for (int i = 3; i < nextLine.Length; i++)
1853:
	1:1854
	10:1856
1854:
	10:1855
1855:        {
1856:            opTree.dtP = this;
1857:
	1:1858
	10:1860
1858:
	10:1859
1859:    {
1860:            {
1861:
	10:1862
1862:        public DecPair<E> Add(E element)
1863:
	10:1864
1864:                return false;
1865:
	10:1866
1866:                    if (i % primes.Get(j) == 0)
1867:
	10:1868
1868:                    {
1869:
	10:1870
1870:                a DecTree containing the element.*/
1871:
	10:1872
1872:                        for (int i = 3; i < nextLine.Length; i++)
1873:
	10:1874
1874:                    i++; //to avoid the colon
1875:
1876:
	0:1877
	1:1880
	2:1884
	3:1888
	4:1890
	5:1892
	6:1894
	7:1896
	8:1898
	9:1900
	10:1902
1877:
	1:1878
1878:
	10:1879
1879:                        {
1880:
	1:1881
	10:1883
1881:
	10:1882
1882:
1883:                case 0:
1884:
	1:1885
	10:1887
1885:
	10:1886
1886:            if (input == "")
1887:            }
1888:
	10:1889
1889:            }
1890:
	10:1891
1891:            catch (NullReferenceException)
1892:
	10:1893
1893:                    }
1894:
	10:1895
1895:            FileStream fs = new FileStream(path, FileMode.Create, FileAccess.Write);
1896:
	10:1897
1897:                    for (; i < nextLine.Length; i++)
1898:
	10:1899
1899:                        {
1900:
	10:1901
1901:                nextLine = sr.ReadLine();
1902:                        break;
1903:
	0:1904
	1:1907
	2:1911
	3:1915
	4:1917
	5:1919
	6:1921
	7:1923
	8:1925
	9:1927
	10:1929
1904:
	1:1905
1905:
	10:1906
1906:                            ds.AddChar(nextLine[i]);
1907:
	1:1908
	10:1910
1908:
	10:1909
1909:        {
1910:                    }
1911:
	1:1912
	10:1914
1912:
	10:1913
1913:        public override string ToString()
1914:            if (longAddress == 0)
1915:
	10:1916
1916:        }
1917:
	10:1918
1918:                return this.Rm(Hasher(0, address));
1919:
	10:1920
1920:            foreach (DecTree<E> member in order)
1921:
	10:1922
1922:                    member.CollectSubTrees(referenceHolder);
1923:
	10:1924
1924:                //repeat for each line.
1925:
	10:1926
1926:                            ds.AddChar(nextLine[i]);
1927:
	10:1928
1928:            while (nextLine != null)
1929:                case 2:
1930:    {
1931:
	0:1932
	1:1960
	2:1989
	3:2016
	4:2043
	5:2070
	6:2097
	7:2124
	8:2151
	9:2178
	10:2205
1932:
	0:1933
	1:1936
	2:1940
	3:1944
	4:1948
	5:1950
	6:1952
	7:1954
	8:1956
	9:1958
1933:
	1:1934
1934:
	10:1935
1935:                    currDecTree = holderTree.Get(index);
1936:
	1:1937
	10:1939
1937:
	10:1938
1938:                        currDecTree.dt8 = holderTree.Get(Int64.Parse(ds.ToString()));
1939:                        break;
1940:
	1:1941
	10:1943
1941:
	10:1942
1942:            Length = 0;
1943:                        break;
1944:
	1:1945
	10:1947
1945:
	10:1946
1946:    public struct DecPair<E>
1947:                int mod = (int)longAddress % 10;
1948:
	10:1949
1949:
1950:
	10:1951
1951:            {
1952:
	10:1953
1953:
1954:
	10:1955
1955:                    {
1956:
	10:1957
1957:                if (nextLine[0] == '\t')
1958:
	10:1959
1959:                        currDecTree.dt7 = holderTree.Get(Int64.Parse(ds.ToString()));
1960:
	0:1961
	1:1964
	2:1968
	3:1972
	4:1976
	5:1978
	6:1980
	7:1982
	8:1984
	9:1986
	10:1988
1961:
	1:1962
1962:
	10:1963
1963:                    else if (nextLine[1] == '1')
1964:
	1:1965
	10:1967
1965:
	10:1966
1966:                        ds.Clear();
1967:                    {
1968:
	1:1969
	10:1971
1969:
	10:1970
1970:            }
1971:                        opTree = this.dt5;
1972:
	1:1973
	10:1975
1973:
	10:1974
1974:
1975:            {
1976:
	10:1977
1977:            }
1978:
	10:1979
1979:                    ChildTree = ChildTree.dtC;
1980:
	10:1981
1981:                {
1982:
	10:1983
1983:                    {
1984:
	10:1985
1985:                    if (nextLine[1] == '0')
1986:
	10:1987
1987:                        ds.Clear();
1988:        public DecTree<E> dt9;
1989:
	0:1990
	1:1993
	2:1997
	3:2001
	4:2003
	5:2005
	6:2007
	7:2009
	8:2011
	9:2013
	10:2015
1990:
	1:1991
1991:
	10:1992
1992:                        }
1993:
	1:1994
	10:1996
1994:
	10:1995
1995:                    }
1996:                        break;
1997:
	1:1998
	10:2000
1998:
	10:1999
1999:        /// <summary>
2000:                case 7:
2001:
	10:2002
2002:                    opTree = opTree.GetDecTree(NEGATIVE);
2003:
	10:2004
2004:            return this.GoGet(Hasher(0, address)).Get();
2005:
	10:2006
2006:            }
2007:
	10:2008
2008:        /// <summary>
2009:
	10:2010
2010:                order[4] = currTree.dt4;
2011:
	10:2012
2012:                    {
2013:
	10:2014
2014:                    }
2015:
2016:
	0:2017
	1:2020
	2:2024
	3:2028
	4:2030
	5:2032
	6:2034
	7:2036
	8:2038
	9:2040
	10:2042
2017:
	1:2018
2018:
	10:2019
2019:                        else if (nextLine[2] == '1')
2020:
	1:2021
	10:2023
2021:
	10:2022
2022:        }
2023:                    {
2024:
	1:2025
	10:2027
2025:
	10:2026
2026:            if (input.Length == 0)
2027:
2028:
	10:2029
2029:            }
2030:
	10:2031
2031:            return opTree.element;
2032:
	10:2033
2033:            {
2034:
	10:2035
2035:            DecTree<E>[] order = new DecTree<E>[] { dt0, dt1, dt2, dt3, dt4, dt5, dt6, dt7, dt8, dt9, dtC, dtN };
2036:
	10:2037
2037:                    if (order[j] != null)
2038:
	10:2039
2039:                        if (nextLine[2] == '0')
2040:
	10:2041
2041:                    index = Int64.Parse(ds.ToString());
2042:        static int NINE = 9;
2043:
	0:2044
	1:2047
	2:2051
	3:2055
	4:2057
	5:2059
	6:2061
	7:2063
	8:2065
	9:2067
	10:2069
2044:
	1:2045
2045:
	10:2046
2046:                    else if (nextLine[1] == '2')
2047:
	1:2048
	10:2050
2048:
	10:2049
2049:        public static char EndOfLine = '\uffff';
2050:                        break;
2051:
	1:2052
	10:2054
2052:
	10:2053
2053:            DecTree<DecString> r_tree1 = new DecTree<DecString>();
2054:                        break;
2055:
	10:2056
2056:            {
2057:
	10:2058
2058:            return opTree.element;
2059:
	10:2060
2060:            {
2061:
	10:2062
2062:                }
2063:
	10:2064
2064:                    }
2065:
	10:2066
2066:                        {
2067:
	10:2068
2068:
2069:        {
2070:
	0:2071
	1:2074
	2:2078
	3:2082
	4:2084
	5:2086
	6:2088
	7:2090
	8:2092
	9:2094
	10:2096
2071:
	1:2072
2072:
	10:2073
2073:                    {
2074:
	1:2075
	10:2077
2075:
	10:2076
2076:            chars.Add(Length++, c);
2077:                case -3:
2078:
	1:2079
	10:2081
2079:
	10:2080
2080:                    opDString = new DecString();
2081:                        opTree = this.dtP;
2082:
	10:2083
2083:                else if (longAddress < 0)
2084:
	10:2085
2085:            {
2086:
	10:2087
2087:            if (primes == null)
2088:
	10:2089
2089:                {
2090:
	10:2091
2091:        public static DecTree<object> Import(string path, ConvertibleObject refObject)
2092:
	10:2093
2093:                    {
2094:
	10:2095
2095:            {
2096:        {
2097:
	0:2098
	1:2101
	2:2105
	3:2109
	4:2111
	5:2113
	6:2115
	7:2117
	8:2119
	9:2121
	10:2123
2098:
	1:2099
2099:
	10:2100
2100:                        for (int i = 3; i < nextLine.Length; i++)
2101:
	1:2102
	10:2104
2102:
	10:2103
2103:                return;
2104:                        opTree = this.dtP;
2105:
	1:2106
	10:2108
2106:
	10:2107
2107:
2108:        }
2109:
	10:2110
2110:                    }
2111:
	10:2112
2112:                return true;
2113:
	10:2114
2114:                {
2115:
	10:2116
2116:                order[6] = currTree.dt6;
2117:
	10:2118
2118:                if (nextLine[0] == '\t')
2119:
	10:2120
2120:                        for (int i = 3; i < nextLine.Length; i++)
2121:
	10:2122
2122:                a DecTree containing the element.*/
2123:        /// </summary>
2124:
	0:2125
	1:2128
	2:2132
	3:2136
	4:2138
	5:2140
	6:2142
	7:2144
	8:2146
	9:2148
	10:2150
2125:
	1:2126
2126:
	10:2127
2127:                        {
2128:
	1:2129
	10:2131
2129:
	10:2130
2130:            if (index > -1 && index < Length)
2131:            return opTree;
2132:
	1:2133
	10:2135
2133:
	10:2134
2134:        DateTime actualDate;
2135:                retTree = retTree.MakeDecTree(NEGATIVE);
2136:
	10:2137
2137:        {
2138:
	10:2139
2139:            }
2140:
	10:2141
2141:                    {
2142:
	10:2143
2143:                        retString.AddString($"\t{j}:{order[j].serializationCounter}\n");
2144:
	10:2145
2145:                {
2146:
	10:2147
2147:                        {
2148:
	10:2149
2149:                    for (; i < nextLine.Length; i++)
2150:        public DecTree<E> MakeDecTree(int type)
2151:
	0:2152
	1:2155
	2:2159
	3:2163
	4:2165
	5:2167
	6:2169
	7:2171
	8:2173
	9:2175
	10:2177
2152:
	1:2153
2153:
	10:2154
2154:                            ds.AddChar(nextLine[i]);
2155:
	1:2156
	10:2158
2156:
	10:2157
2157:        public void AddString(String starter)
2158:                    {
2159:
	1:2160
	10:2162
2160:
	10:2161
2161:                return null;
2162:            return retTree;
2163:
	10:2164
2164:            opTree.dtC = new DecTree<E>(CHILD);
2165:
	10:2166
2166:            {
2167:
	10:2168
2168:                    // LOOP ENDS HERE
2169:
	10:2170
2170:            DecTree<E>[] order = new DecTree<E>[] { dt0, dt1, dt2, dt3, dt4, dt5, dt6, dt7, dt8, dt9, dtC, dtN };
2171:
	10:2172
2172:                    {
2173:
	10:2174
2174:                            ds.AddChar(nextLine[i]);
2175:
	10:2176
2176:                //repeat for each line.
2177:                    }
2178:
	0:2179
	1:2182
	2:2186
	3:2190
	4:2192
	5:2194
	6:2196
	7:2198
	8:2200
	9:2202
	10:2204
2179:
	1:2180
2180:
	10:2181
2181:                        }
2182:
	1:2183
	10:2185
2183:
	10:2184
2184:            long starter_length = starter.chars.Length();
2185:
2186:
	1:2187
	10:2189
2187:
	10:2188
2188:        {
2189:            {
2190:
	10:2191
2191:
2192:
	10:2193
2193:            }
2194:
	10:2195
2195:            {
2196:
	10:2197
2197:                }
2198:
	10:2199
2199:            }
2200:
	10:2201
2201:                        }
2202:
	10:2203
2203:            {
2204:                    {
2205:
2206:
	0:2207
	1:2235
	2:2264
	3:2291
	4:2318
	5:2345
	6:2372
	7:2399
	8:2426
	9:2453
	10:2480
2207:
	0:2208
	1:2211
	2:2215
	3:2219
	4:2223
	5:2225
	6:2227
	7:2229
	8:2231
	9:2233
2208:
	1:2209
2209:
	10:2210
2210:                    if (nextLine[1] == '0')
2211:
	1:2212
	10:2214
2212:
	10:2213
2213:                        ds.Clear();
2214:                    }
2215:
	1:2216
	10:2218
2216:
	10:2217
2217:            this.AddString(init);
2218:                    }
2219:
	1:2220
	10:2222
2220:
	10:2221
2221:    {
2222:                longAddress /= 10;
2223:
	10:2224
2224:        public DecTree<E> TGet(String address)
2225:
	10:2226
2226:                DecTree<E> FocusTree = this;
2227:
	10:2228
2228:        /// <summary>
2229:
	10:2230
2230:                        nextline_bytes[j] = (byte)nextline[j];
2231:
	10:2232
2232:                /*here, we do the references.
2233:
	10:2234
2234:                        ds.Clear();
2235:
	0:2236
	1:2239
	2:2243
	3:2247
	4:2251
	5:2253
	6:2255
	7:2257
	8:2259
	9:2261
	10:2263
2236:
	1:2237
2237:
	10:2238
2238:                    {
2239:
	1:2240
	10:2242
2240:
	10:2241
2241:                    }
2242:                        this.dt5 ??= new DecTree<E>(FIVE);
2243:
	1:2244
	10:2246
2244:
	10:2245
2245:            return (new string(allChars));
2246:                        break;
2247:
	1:2248
	10:2250
2248:
	10:2249
2249:        public abstract override string ToString();
2250:                DecTree<E> retTree = this;
2251:
	10:2252
2252:        }
2253:
	10:2254
2254:                    FocusTree = FocusTree.dtC;
2255:
	10:2256
2256:                    this.Get(i);
2257:
	10:2258
2258:                        nextline_bytes[j] = (byte)nextline[j];
2259:
	10:2260
2260:                    {
2261:
	10:2262
2262:                    }
2263:        public DecTree<E> dtC;
2264:
	0:2265
	1:2268
	2:2272
	3:2276
	4:2278
	5:2280
	6:2282
	7:2284
	8:2286
	9:2288
	10:2290
2265:
	1:2266
2266:
	10:2267
2267:                        if (nextLine[2] == '0')
2268:
	1:2269
	10:2271
2269:
	10:2270
2270:                    index = Int64.Parse(ds.ToString());
2271:                    }
2272:
	1:2273
	10:2275
2273:
	10:2274
2274:        /// splits strings by space characters, stores each splice in a
2275:                    {
2276:
	10:2277
2277:                    address *= -1;
2278:
	10:2279
2279:        }
2280:
	10:2281
2281:        }
2282:
	10:2283
2283:        /// OUTPUT FORMAT:
2284:
	10:2285
2285:                order[5] = currTree.dt5;
2286:
	10:2287
2287:                        if (nextLine[2] == ':')
2288:
	10:2289
2289:                }
2290:        static int ZERO = 0;
2291:
	0:2292
	1:2295
	2:2299
	3:2303
	4:2305
	5:2307
	6:2309
	7:2311
	8:2313
	9:2315
	10:2317
2292:
	1:2293
2293:
	10:2294
2294:                        {
2295:
	1:2296
	10:2298
2296:
	10:2297
2297:    }
2298:                        this.dt8 ??= new DecTree<E>(EIGHT);
2299:
	1:2300
	10:2302
2300:
	10:2301
2301:            {
2302:                case 9:
2303:
	10:2304
2304:            catch (NullReferenceException)
2305:
	10:2306
2306:        }
2307:
	10:2308
2308:                return false;
2309:
	10:2310
2310:            DecTree<DecTree<E>> referenceHolder = new DecTree<DecTree<E>>();
2311:
	10:2312
2312:                    {
2313:
	10:2314
2314:                        {
2315:
	10:2316
2316:                    ds.Clear();
2317:        static int NEGATIVE = -1;
2318:
	0:2319
	1:2322
	2:2326
	3:2330
	4:2332
	5:2334
	6:2336
	7:2338
	8:2340
	9:2342
	10:2344
2319:
	1:2320
2320:
	10:2321
2321:                    {
2322:
	1:2323
	10:2325
2323:
	10:2324
2324:
2325:                    }
2326:
	1:2327
	10:2329
2327:
	10:2328
2328:            DecString opDString = new DecString();
2329:                    }
2330:
	10:2331
2331:                DecTree<E> retTree = this;
2332:
	10:2333
2333:        }
2334:
	10:2335
2335:                hashValue += tag[i] * Prime(i);
2336:
	10:2337
2337:            }
2338:
	10:2339
2339:                }
2340:
	10:2341
2341:                            for (int i = 4; i < nextLine.Length; i++)
2342:
	10:2343
2343:        public static DecTree<string> Import(string path)
2344:            this.type = type;
2345:
	0:2346
	1:2349
	2:2353
	3:2357
	4:2359
	5:2361
	6:2363
	7:2365
	8:2367
	9:2369
	10:2371
2346:
	1:2347
2347:
	10:2348
2348:                        for (int i = 3; i < nextLine.Length; i++)
2349:
	1:2350
	10:2352
2350:
	10:2351
2351:        }
2352:                    {
2353:
	1:2354
	10:2356
2354:
	10:2355
2355:                    stringIndex = 0;
2356:                        break;
2357:
	10:2358
2358:                {
2359:
	10:2360
2360:                return default(DecTree<E>);
2361:
	10:2362
2362:            {
2363:
	10:2364
2364:                    retString.AddString($"{i}:{currTree.element.ToString()}\n");
2365:
	10:2366
2366:        {
2367:
	10:2368
2368:                        for (int i = 3; i < nextLine.Length; i++)
2369:
	10:2370
2370:                if (nextLine[0] == '\t')
2371:            this.counter--;
2372:
	0:2373
	1:2376
	2:2380
	3:2384
	4:2386
	5:2388
	6:2390
	7:2392
	8:2394
	9:2396
	10:2398
2373:
	1:2374
2374:
	10:2375
2375:                        {
2376:
	1:2377
	10:2379
2377:
	10:2378
2378:            }
2379:                        break;
2380:
	1:2381
	10:2383
2381:
	10:2382
2382:#pragma warning disable 168
2383:        public DecTree<E> PaveTo(long address)
2384:
	10:2385
2385:                return opTree;
2386:
	10:2387
2387:            }
2388:
	10:2389
2389:                    break;
2390:
	10:2391
2391:                order[7] = currTree.dt7;
2392:
	10:2393
2393:                //First pass. Must read in all DecTrees before it makes sense to pass references to them.
2394:
	10:2395
2395:                        {
2396:
	10:2397
2397:                {
2398:        public void counterIncrement()
2399:
	0:2400
	1:2403
	2:2407
	3:2411
	4:2413
	5:2415
	6:2417
	7:2419
	8:2421
	9:2423
	10:2425
2400:
	1:2401
2401:
	10:2402
2402:                            ds.AddChar(nextLine[i]);
2403:
	1:2404
	10:2406
2404:
	10:2405
2405:            {
2406:        }
2407:
	1:2408
	10:2410
2408:
	10:2409
2409:
2410:                address *= -1;
2411:
	10:2412
2412:            DecTree<E> opTree = this;
2413:
	10:2414
2414:        }
2415:
	10:2416
2416:                        break;
2417:
	10:2418
2418:                    }
2419:
	10:2420
2420:                    int i = 0;
2421:
	10:2422
2422:                            ds.AddChar(nextLine[i]);
2423:
	10:2424
2424:                    {
2425:        {
2426:
	0:2427
	1:2430
	2:2434
	3:2438
	4:2440
	5:2442
	6:2444
	7:2446
	8:2448
	9:2450
	10:2452
2427:
	1:2428
2428:
	10:2429
2429:                        }
2430:
	1:2431
	10:2433
2431:
	10:2432
2432:        {
2433:                        opTree = this.dt0;
2434:
	1:2435
	10:2437
2435:
	10:2436
2436:
2437:        }
2438:
	10:2439
2439:            opTree.dtC.element = element;
2440:
	10:2441
2441:                return false;
2442:
	10:2443
2443:                }
2444:
	10:2445
2445:            DecTree<DecTree<E>> referenceHolder = new DecTree<DecTree<E>>();
2446:
	10:2447
2447:                        ds.AddChar(nextLine[i]);
2448:
	10:2449
2449:                        }
2450:
	10:2451
2451:            }
2452:
2453:
	0:2454
	1:2457
	2:2461
	3:2465
	4:2467
	5:2469
	6:2471
	7:2473
	8:2475
	9:2477
	10:2479
2454:
	1:2455
2455:
	10:2456
2456:                        currDecTree.dt7 = holderTree.Get(Int64.Parse(ds.ToString()));
2457:
	1:2458
	10:2460
2458:
	10:2459
2459:            for (long i = 0; i < starter_length; i++)
2460:                case 2:
2461:
	1:2462
	10:2464
2462:
	10:2463
2463:            return actualDate.ToString();
2464:                return this;
2465:
	10:2466
2466:        public DecPair<E> Add(string address, E element)
2467:
	10:2468
2468:            catch (NullReferenceException)
2469:
	10:2470
2470:                if (member != null)
2471:
	10:2472
2472:            }
2473:
	10:2474
2474:
2475:
	10:2476
2476:                        currDecTree.dt6 = holderTree.Get(Int64.Parse(ds.ToString()));
2477:
	10:2478
2478:                if (nextLine[0] == '\t')
2479:                        this.dt2 ??= new DecTree<E>(TWO);
2480:        public DecTree<E> dt0;
2481:
	0:2482
	1:2510
	2:2539
	3:2566
	4:2593
	5:2620
	6:2647
	7:2674
	8:2701
	9:2728
	10:2755
2482:
	0:2483
	1:2486
	2:2490
	3:2494
	4:2498
	5:2500
	6:2502
	7:2504
	8:2506
	9:2508
2483:
	1:2484
2484:
	10:2485
2485:                    {
2486:
	1:2487
	10:2489
2487:
	10:2488
2488:                    }
2489:                case 4:
2490:
	1:2491
	10:2493
2491:
	10:2492
2492:        }
2493:                case 4:
2494:
	1:2495
	10:2497
2495:
	10:2496
2496:        public static implicit operator DecTree<E>(DecPair<E> subject) { return subject.Tree; }
2497:                retTree = retTree.MakeDecTree(mod);
2498:
	10:2499
2499:        {
2500:
	10:2501
2501:                DecTree<E> ChildTree;
2502:
	10:2503
2503:        /// Just counts from 0 until exception, upwards
2504:
	10:2505
2505:                    }
2506:
	10:2507
2507:                The approach is as follows:
2508:
	10:2509
2509:                    }
2510:
	0:2511
	1:2514
	2:2518
	3:2522
	4:2526
	5:2528
	6:2530
	7:2532
	8:2534
	9:2536
	10:2538
2511:
	1:2512
2512:
	10:2513
2513:                        if (nextLine[2] == ':')
2514:
	1:2515
	10:2517
2515:
	10:2516
2516:                }
2517:                        opTree = this.dt5;
2518:
	1:2519
	10:2521
2519:
	10:2520
2520:        }
2521:                    }
2522:
	1:2523
	10:2525
2523:
	10:2524
2524:
2525:                DecTree<E> opTree = retTree;
2526:
	10:2527
2527:
2528:
	10:2529
2529:                }
2530:
	10:2531
2531:                }
2532:
	10:2533
2533:                    }
2534:
	10:2535
2535:                        for (int i = 3; i < nextLine.Length; i++)
2536:
	10:2537
2537:                    else if (nextLine[1] == '9')
2538:        public DecTree<E> dtN;
2539:
	0:2540
	1:2543
	2:2547
	3:2551
	4:2553
	5:2555
	6:2557
	7:2559
	8:2561
	9:2563
	10:2565
2540:
	1:2541
2541:
	10:2542
2542:                        {
2543:
	1:2544
	10:2546
2544:
	10:2545
2545:                    ds.Clear();
2546:
2547:
	1:2548
	10:2550
2548:
	10:2549
2549:        /// child DecTree, stores it at the next available index--INDEXING
2550:                        opTree = this.dt7;
2551:
	10:2552
2552:                }
2553:
	10:2554
2554:
2555:
	10:2556
2556:
2557:
	10:2558
2558:        /// $"[{DecTree Index}] : <{element.ToString()}>\n"
2559:
	10:2560
2560:                order[6] = currTree.dt6;
2561:
	10:2562
2562:                        {
2563:
	10:2564
2564:                else
2565:        static int ONE = 1;
2566:
	0:2567
	1:2570
	2:2574
	3:2578
	4:2580
	5:2582
	6:2584
	7:2586
	8:2588
	9:2590
	10:2592
2567:
	1:2568
2568:
	10:2569
2569:                            for (int i = 4; i < nextLine.Length; i++)
2570:
	1:2571
	10:2573
2571:
	10:2572
2572:    /// <summary>
2573:                        opTree = this.dt8;
2574:
	1:2575
	10:2577
2575:
	10:2576
2576:                DecTree<DecString> r_tree = new DecTree<DecString>();
2577:                    {
2578:
	10:2579
2579:            {
2580:
	10:2581
2581:
2582:
	10:2583
2583:            }
2584:
	10:2585
2585:            referenceHolder.Add(0, this);
2586:
	10:2587
2587:                        char[] nextline = $"\t{j}:{order[j].serializationCounter}\n".ToCharArray();
2588:
	10:2589
2589:                            for (int i = 4; i < nextLine.Length; i++)
2590:
	10:2591
2591:                }
2592:        static int CHILD = -3;
2593:
	0:2594
	1:2597
	2:2601
	3:2605
	4:2607
	5:2609
	6:2611
	7:2613
	8:2615
	9:2617
	10:2619
2594:
	1:2595
2595:
	10:2596
2596:                        for (int i = 3; i < nextLine.Length; i++)
2597:
	1:2598
	10:2600
2598:
	10:2599
2599:        public DecString()
2600:
2601:
	1:2602
	10:2604
2602:
	10:2603
2603:            while (charCounter < input.Length)
2604:
2605:
	10:2606
2606:                DecTree<E> opTree = retTree;
2607:
	10:2608
2608:
2609:
	10:2610
2610:            }
2611:
	10:2612
2612:            for (int i = 0; i <= referenceHolder.counter; i++)
2613:
	10:2614
2614:            }
2615:
	10:2616
2616:                            {
2617:
	10:2618
2618:        {
2619:        }
2620:
	0:2621
	1:2624
	2:2628
	3:2632
	4:2634
	5:2636
	6:2638
	7:2640
	8:2642
	9:2644
	10:2646
2621:
	1:2622
2622:
	10:2623
2623:                        {
2624:
	1:2625
	10:2627
2625:
	10:2626
2626:
2627:                        this.dtC ??= new DecTree<E>(CHILD);
2628:
	1:2629
	10:2631
2629:
	10:2630
2630:                }
2631:                    }
2632:
	10:2633
2633:                    opTree = opTree.GetDecTree(NEGATIVE);
2634:
	10:2635
2635:            }
2636:
	10:2637
2637:                primes = new DecTree<long>();
2638:
	10:2639
2639:                }
2640:
	10:2641
2641:            DecTree<DecTree<object>> holderTree = new DecTree<DecTree<object>>();
2642:
	10:2643
2643:                        {
2644:
	10:2645
2645:                //First pass. Must read in all DecTrees before it makes sense to pass references to them.
2646:            if (this.dtP != null)
2647:
	0:2648
	1:2651
	2:2655
	3:2659
	4:2661
	5:2663
	6:2665
	7:2667
	8:2669
	9:2671
	10:2673
2648:
	1:2649
2649:
	10:2650
2650:                            ds.AddChar(nextLine[i]);
2651:
	1:2652
	10:2654
2652:
	10:2653
2653:            else
2654:                    }
2655:
	1:2656
	10:2658
2656:
	10:2657
2657:        public bool Stable()
2658:        {
2659:
	10:2660
2660:            }
2661:
	10:2662
2662:            else if (this.dtC != null && this.dtC.dtC == null)
2663:
	10:2664
2664:                }
2665:
	10:2666
2666:                order[8] = currTree.dt8;
2667:
	10:2668
2668:                {
2669:
	10:2670
2670:                            ds.AddChar(nextLine[i]);
2671:
	10:2672
2672:                    int i = 0;
2673:        {
2674:
	0:2675
	1:2678
	2:2682
	3:2686
	4:2688
	5:2690
	6:2692
	7:2694
	8:2696
	9:2698
	10:2700
2675:
	1:2676
2676:
	10:2677
2677:                        }
2678:
	1:2679
	10:2681
2679:
	10:2680
2680:                return chars.Get(index);
2681:
2682:
	1:2683
	10:2685
2683:
	10:2684
2684:        public DecTime(DateTime present)
2685:            }
2686:
	10:2687
2687:            DecPair<E> retPair = new DecPair<E>();
2688:
	10:2689
2689:
2690:
	10:2691
2691:                    }
2692:
	10:2693
2693:                }
2694:
	10:2695
2695:                    for (; nextLine[i] > 0x2f && nextLine[i] < 0x3a; i++)
2696:
	10:2697
2697:                        }
2698:
	10:2699
2699:                        ds.AddChar(nextLine[i]);
2700:            DecTree<E> opTree;
2701:
	0:2702
	1:2705
	2:2709
	3:2713
	4:2715
	5:2717
	6:2719
	7:2721
	8:2723
	9:2725
	10:2727
2702:
	1:2703
2703:
	10:2704
2704:                        currDecTree.dt6 = holderTree.Get(Int64.Parse(ds.ToString()));
2705:
	1:2706
	10:2708
2706:
	10:2707
2707:            for (int i = 0; i < starter.Length; i++)
2708:                        break;
2709:
	1:2710
	10:2712
2710:
	10:2711
2711:            return new DecTime(DateTime.Parse(input));
2712:
2713:
	10:2714
2714:            retPair.Tree = opTree;
2715:
	10:2716
2716:            }
2717:
	10:2718
2718:            }
2719:
	10:2720
2720:            referenceHolder.Add(0, this);
2721:
	10:2722
2722:                    }
2723:
	10:2724
2724:                        currDecTree.dt5 = holderTree.Get(Int64.Parse(ds.ToString()));
2725:
	10:2726
2726:
2727:                case 1:
2728:
	0:2729
	1:2732
	2:2736
	3:2740
	4:2742
	5:2744
	6:2746
	7:2748
	8:2750
	9:2752
	10:2754
2729:
	1:2730
2730:
	10:2731
2731:                        ds.Clear();
2732:
	1:2733
	10:2735
2733:
	10:2734
2734:            {
2735:                    {
2736:
	1:2737
	10:2739
2737:
	10:2738
2738:        }
2739:            }
2740:
	10:2741
2741:        {
2742:
	10:2743
2743:            {
2744:
	10:2745
2745:                {
2746:
	10:2747
2747:            for (int i = 0; i <= referenceHolder.counter; i++)
2748:
	10:2749
2749:            sr.Close();
2750:
	10:2751
2751:                        ds.Clear();
2752:
	10:2753
2753:                /*here, we do the references.
2754:                        opTree = this.dt2;
2755:        public DecTree<E> dt1;
2756:using System;
